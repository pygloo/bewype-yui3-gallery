
    /**
     *
     */
    var PLACE_TMPL  = '',
        BUTTON_TMPL = '',
        Editor      = null;

    /**
     *
     */
    PLACE_TMPL += '<div class="{editorClass}-place">';
    PLACE_TMPL += '</div>';

    /**
     *
     */
    BUTTON_TMPL += '<div class="{editorClass}">';
    BUTTON_TMPL += '</div>';

    /**
     *
     */
    Editor = function(config) {
        Editor.superclass.constructor.apply( this, arguments );
    };

    /**
     *
     */
    Editor.NAME = "bewypeEditor";

    /**
     *
     */
    Editor.NS   = 'bewypeEditor';

    /**
     *
     */
    Editor.ATTRS = {
        editorClass : {
            value : 'yui3-bewype-editor',
            writeOnce : true,
            validator : function( val ) {
                return Y.Lang.isString( val );
            }
        },
        activeButtons : {
            value : [ 'bold', 'italic', 'underline', 'font-family', 'font-size'  ],
            writeOnce : true
        },
        panelNode : {
            value : null,
            writeOnce : true
        }
    };

    Y.extend( Editor, Y.Plugin.Base, {

        /**
         *
         */
        _editor     : null,

        _buttonDict : {},

        _fontDict   : {},

        _toggleButtons  : [ 'bold', 'italic', 'underline' ],

        _pickerButtons  : [ 'font-family', 'font-size' ],

        _pickerObjDict : {
            'font-family' : Y.Bewype.PickerFontFamily,
            'font-size'   : Y.Bewype.PickerFontSize
        },

        _tagButtons  : [ 'bold', 'italic', 'underline' ],

        _cssButtons  : [ 'font-family', 'font-size' ],

        _selectedNodeList : null,

        /**
         *
         */
        _initEditor : function () {

            var _host        = this.get( 'host'        ),
                _editorClass = this.get( 'editorClass' ),
                _placeNode   = null,
                _main        = new Y.Node.create( '<div><div class="main" /></div>' );

            // set content to main
            _main.one( '.main' ).append( this._getInnerHTML( _host ) );
            
            // and empty tag content temporary
            _host.set( 'innerHTML', '' );

            // create place node
            _placeNode = new Y.Node.create(
                Y.substitute( PLACE_TMPL, {
                    editorClass : _editorClass
                } )
            );
            // add new node for the editor
            _host.append( _placeNode );

            //Create the Base Editor
            this._editor = new Y.EditorBase( {
                content : _main.get( 'innerHTML' )
            } );

            //Rendering the Editor
            this._editor.render( _placeNode );

            // add custom event listener
            this._editor.after( 'nodeChange', Y.bind( this._onEditorChange, this ) );
        },

        _initContent : function () {

            // get host
            var _host       = this.get( 'host' ),
                _cssDict    = Y.Bewype.Utils.getCssDict( _host ),
                _placeClass = this.get( 'editorClass' ) + '-place',
                _placeNode  = _host.one( '.' + _placeClass ),
                _body       = this._editor.getInstance().one( 'body' ),
                _main       = _body.one( '.main' ),
                _fn         = null;

            // ensure nice body
            _body.setStyle( 'cssText',  'padding: 0; margin: 0;');

            _fn = function ( key, val ) {

                var _isHeightOrWidth = [ 'height', 'width' ].indexOf( key ) != -1,
                    _keySplt         = key.split( '-' ),
                    _hasBorder       = _keySplt.indexOf( 'border'  ) != -1,
                    _hasFont         = _keySplt.indexOf( 'font'    ) != -1,
                    _hasPadding      = _keySplt.indexOf( 'padding' ) != -1;

                // place or content style factory
                if ( _isHeightOrWidth || _hasBorder || _hasPadding ) {

                    // style for the edited place
                    _placeNode.setStyle( Y.Bewype.Utils.camelize( key ), val );

                } else if ( key ) {                    

                    // style for the edited content
                    _main.setStyle( Y.Bewype.Utils.camelize( key ), val );

                }

                // update font dict
                if ( _hasFont ) {
                    this._fontDict[ key ] = val;
                }

                // return something to continue
                return val;
            };

            // separate place and content style
            Y.JSON.stringify( _cssDict, Y.bind( _fn, this ) );

            // clear previous css
            _host.setStyle( 'cssText',  '');
        },

        _initPanel : function () {

            var _activeButtons = this.get( 'activeButtons' );

            Y.Object.each( this._toggleButtons , function( v, k ) {
                // check active
                if ( _activeButtons.indexOf( v ) != -1 ) { 
                    // do add
                    this._addToggleButton( v );
                }
            }, this );

            Y.Object.each( this._pickerButtons , function( v, k ) {
                // check active
                if ( _activeButtons.indexOf( v ) != -1 ) { 
                    // do add
                    this._addPickerButton( v, this._pickerObjDict[ v ] );
                }
            }, this );
        },

        /**
         *
         */
        initializer : function( config ) {

            // add editor
            this._initEditor();

            // set editor content
            this._initContent();

            // set panel
            this._initPanel();
        },

        /**
         *
         */
        destructor : function () {

            if ( !this._editor ) {
                return;
            }
    
            // tmp vars
            var _host          = this.get( 'host'        ),
                _panelNode     = this.get( 'panelNode'   ),
                _editorClass   = this.get( 'editorClass' ),
                _placeClass    = '.' + _editorClass + '-place',
                _placeNode     = _host.one( _placeClass ),
                _body          = this._editor.getInstance().one( 'body' ),
                _main          = _body.one( '.main' ),
                _selectionNode = _main.one( '.selection' ),
                _fn            = null;

            // hide first
            this._editor.hide();

            // remove selection node
            _selectionNode.replace( this._getInnerHTML( _selectionNode ) );

            // restore content
            _host.set( 'innerHTML', _main.get( 'innerHTML' ) );

            // css spliter
            _fn = function ( type_, key, val ) {
                // do update
                if ( key ) {
                    if ( type_ === 'content' && key.split( '-' ).indexOf( 'padding' ) != -1 ) {
                        // do nothing
                    } else {
                        _host.setStyle( Y.Bewype.Utils.camelize( key ), val );
                    }
                }
                // return somethign to continue
                return val;
            };
            // separate place and content style
            Y.JSON.stringify( Y.Bewype.Utils.getCssDict( _placeNode ), Y.bind( _fn, this, 'place'   ) );
            Y.JSON.stringify( Y.Bewype.Utils.getCssDict( _main      ), Y.bind( _fn, this, 'content' ) );

            // destroy editor
            this._editor.destroy();

            Y.Object.each( this.get( 'activeButtons' ) , function( v, k ) {

                // remove button
                this._buttonDict[ v ].destroy();
                delete( this._buttonDict[ v ] );

                // remove node
                _panelNode.one( '.' + _editorClass + '-toggle-button-' + v ).remove();

            }, this );

            this._buttonDict = {};

            this._fontDict   = {};
        },

        _addToggleButton : function ( name ) {

            var _panelNode   = this.get( 'panelNode'   ),
                _editorClass = this.get( 'editorClass' ),
                _buttonNode  = null,
                _button      = null;

            // create node
            _buttonNode = new Y.Node.create(
                Y.substitute( BUTTON_TMPL, {
                    editorClass : _editorClass + '-toggle-button-' + name
                } )
            );
            // add new node for the panel
            _panelNode.append( _buttonNode );

            // create\render toggle button
            _button = new Y.Bewype.ButtonToggle( {
                label : name
            } );
            _button.render( _buttonNode );

            // add custom event listener
            _button.on( 'button:onChange', Y.bind( this._onButtonChange, this, name ) );

            // update button dict
            this._buttonDict[ name ] = _button;
        },

        _addPickerButton : function ( name, pickerObj ) {

            var _panelNode   = this.get( 'panelNode'   ),
                _editorClass = this.get( 'editorClass' ),
                _buttonNode  = null,
                _button      = null;

            // create node
            _buttonNode = new Y.Node.create(
                Y.substitute( BUTTON_TMPL, {
                    editorClass : _editorClass + '-toggle-button-' + name
                } )
            );
            // add new node for the panel
            _panelNode.append( _buttonNode );

            // create\render toggle button
            _button = new Y.Bewype.ButtonPicker( {
                label     : name,
                pickerObj :  pickerObj
            } );
            _button.render( _buttonNode );

            // add custom event listener
            _button.on( 'button:onChange', Y.bind( this._onButtonChange, this, name ) );

            // update button dict
            this._buttonDict[ name ] = _button;
        },

        _hasLeftBlank : function (str){
            if (str.length === 0) {
                return false;
            } else if ( str.substring(0, 1).trim().length === 0 ) {
                return true;
            }
            return false;
        },

        _hasRightBlank : function (str){
            if (str.length === 0) {
                return false;
            } else if ( str.substring(str.length - 1, str.length).trim().length === 0 ) {
                return true;
            }
            return false;
        },

        _getInnerHTML : function ( node, raw ) {
            // get text
            var _node = node._node ? node._node : node,
                _html = _node.innerHTML,
                _t    = '';
            // ensure blank
            _t += this._hasLeftBlank( _html )  ? '&nbsp;' : '';
            _t += _html.trim();
            _t += this._hasRightBlank( _html ) ? '&nbsp;' : '';
            // update new node
            return raw ? _t : _t.trim() === '' ? null : new Y.Node.create( _t );
        },

        _getWorkingTagName : function ( name ) {

            switch( name ) {
                case 'bold':
                    return 'b';

                case 'italic':
                    return 'i';

                case 'underline':
                    return 'u';

                default:
                    return 'span';
            }
        },

        _removeTag : function ( node, selector, styleProperty ) {
            // little check
            if ( node ) {
                node.all( selector ).each( function ( v, k ) {
                    var _cssDict = null,
                        _innerHTML = null,
                        _l = null;
                    if ( styleProperty ) {
                        // get css dict
                        _cssDict = Y.Bewype.Utils.getCssDict( v );
                        // remove property
                        if ( _cssDict[ styleProperty ] ) {                    
                            delete( _cssDict[ styleProperty ] );
                        }
                        // reset css without property
                        Y.Bewype.Utils.setCssDict( v, _cssDict );
                        // keep it?
                        _l = Y.Object.keys( _cssDict ).length;
                        if ( _l !== 0 ) {
                            return;
                        }
                    }
                    _innerHTML = this._getInnerHTML( v );
                    if ( !_innerHTML ) {
                        v.remove();
                    } else {
                        v.replace( this._getInnerHTML( v ) );
                    }
                }, this );
            }
        },

        _updateMainStyle : function ( name, node ) {

            // tmp vars
            var _host            = this.get( 'host' ),
                _isHeightOrWidth = [ 'height', 'width' ].indexOf( name ) != -1,
                _keySplt         = name.split( '-' ),
                _hasPadding      = _keySplt.indexOf( 'padding' ) != -1,
                _node            = node ? node : null,
                _value           = this._buttonDict[ name ].getValue();

            if ( !_node ) {
                // get place or content node factory
                if ( _isHeightOrWidth || _hasPadding ) {
                    // get place node
                    _node = _host.one( '.' + this.get( 'editorClass' ) + '-place' );
                } else {
                    // get content node
                    _node = this._editor.getInstance().one( '.main' );
                }
            }

            if ( node ) {
                // do update
                node.setStyle( Y.Bewype.Utils.camelize( name ), _value );
            }
        },
        
        _clearSelection : function ( selection, range ) {
            if ( selection.clear ) {
                selection.clear();
            } else if ( selection.removeAllRanges ) {
                range.detach();
                selection.removeAllRanges();
            } else {
                return;
            }
        },

        _onEditorChange : function ( e ) {

            var _host             = this.get( 'host' ),
                _inst             = this._editor.getInstance(),
                _body             = _inst.one( 'body'  ),
                _main             = _body.one( '.main' ),
                _selectionNode    = _main.one( '.selection' ),
                _selection        = null,
                _range            = null,
                _pNode            = null,
                _fNode            = null,
                _cK               = 0;

            //
            if ( e.changedEvent.type == 'dblclick' ) {

            } else if ( e.changedEvent.type == 'mouseup' ) {

                _selection        = Y.Bewype.Utils.getSelection( _host );
                _range            = Y.Bewype.Utils.getSelectedRange( _selection );

                // little check
                if ( !_selection.anchorNode || !_selection.focusNode ) {
                    this._clearSelection( _selection, _range );
                    return this._removeTag(_main, '.selection');
                }                        

                // remove previous surrounding node
                if ( _selectionNode ) {
                    _selectionNode.replace( this._getInnerHTML( _selectionNode ) );
                }
                
                if ( _selection.anchorNode != _selection.focusNode || _selection.anchorOffset != _selection.focusOffset ) {

                    if ( _selection.anchorNode.parentNode != _main._node ) {
                        _pNode = _selection.anchorNode;
                        _cK = 0;
                        try {
                            while ( _pNode.parentNode && _pNode.parentNode != _main._node) {
                                _pNode = _pNode.parentNode;
                                // manage endless case :s
                                _cK += 1;
                                if ( _cK == 10 ) {
                                    break;
                                }
                            }
                            _range.setStartBefore( _pNode );
                        } catch ( e1 ) {
                            this._clearSelection( _selection, _range );
                            return this._removeTag(_main, '.selection');
                        }
                    } else if ( _selection.anchorOffset === 0 && !_selection.anchorNode.previousSibling ) {
                        _range.setStart( _main._node, 0);
                    }

                    if ( _selection.focusNode.parentNode != _main._node ) {
                        _fNode = _selection.focusNode;
                        _cK = 0;
                        try {
                            while ( _fNode.parentNode && _fNode.parentNode != _main._node) {
                                _fNode = _fNode.parentNode;
                                // manage endless case :s
                                _cK += 1;
                                if ( _cK == 10 ) {
                                    break;
                                }
                            }
                            _range.setEndAfter( _fNode );
                        } catch ( e2 ) {
                            this._clearSelection( _selection, _range );
                            return this._removeTag(_main, '.selection');
                        }
                    }
                    try {
                        // create new surrounding node                             
                        _selectionNode = Y.Node.create( '<span class="selection"></span>' );
                        _main.append( _selectionNode );
                        // set range surrounding node
                        _range.surroundContents( _main.one( '.selection' )._node );
                    } catch ( e3 ) {
                        this._clearSelection( _selection, _range );
                        return this._removeTag(_main, '.selection');
                    }
                    //
                    this._clearSelection( _selection, _range );

                } else {
                    this._removeTag(_main, '.selection');
                }

                // udpate selection node
                _selectionNode = _main.one( '.selection' );

                Y.Object.each( this.get( 'activeButtons' ) , function( v, k ) {
                    switch( v ) {
                        case 'bold':
                            this._buttonDict[ v ].setValue( _selectionNode && _selectionNode.one( 'b' ) !== null );
                            break;
                        case 'italic':
                            this._buttonDict[ v ].setValue( _selectionNode && _selectionNode.one( 'i' ) !== null );
                            break;
                        case 'underline':
                            this._buttonDict[ v ].setValue( _selectionNode && _selectionNode.one( 'u' ) !== null );
                            break;
                    }
                }, this );
            }

            if ( _selectionNode ) {                
                _selectionNode.setStyle( 'backgroundColor', '#ddd');
                _selectionNode.setStyle( 'display', 'inline-block');
            }
        },

        _onButtonChange : function ( name, e ) {

            var _inst             = this._editor.getInstance(),
                _body             = _inst.one( 'body'  ),
                _main             = _body.one( '.main' ),
                _selectionNode    = _main.one( '.selection' ),
                _value            = this._buttonDict[ name ].getValue(),
                _tag              = null,
                _tagNode          = null,
                _newNode          = null;             

            if ( !_selectionNode ) {
                if ( this._cssButtons.indexOf( name ) != -1 ) {
                    return this._updateMainStyle( name );
                }
            }
            
            if ( _selectionNode ) {
                // get new tag
                _tag = this._getWorkingTagName( name );

                // do some cleaning
                this._removeTag( _selectionNode, _tag, name );

                if ( _value ) {

                    // create tag node
                    _tagNode = Y.Node.create( '<' + _tag + '></' + _tag + '>' );

                    // update with css property
                    if ( this._cssButtons.indexOf( name ) != -1 ) {
                        _tagNode.setStyle( Y.Bewype.Utils.camelize( name ), _value);
                    }

                    // create surrounding node
                    _newNode = Y.Node.create( '<span class="selection"></span>' );
                    _newNode.append( _tagNode );
                    //
                    _newNode.one( _tag ).append( this._getInnerHTML( _selectionNode ) );

                    // update current selection
                    _selectionNode.replace(_newNode);
                }
            }

            // udpate selection style;
            _selectionNode = _main.one( '.selection' );
            if ( _selectionNode ) {                
                _selectionNode.setStyle( 'backgroundColor', '#ddd');
                _selectionNode.setStyle( 'display', 'inline-block');

                // do some cleaning
                this._removeTag( _main, 'span', name );
            }
        }
    } );

    Y.namespace('Bewype');
    Y.Bewype.Editor = Editor;

